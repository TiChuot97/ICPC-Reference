\documentclass[10pt,landscape]{article}
\usepackage{multicol}
\usepackage{listings}
\usepackage{color}
\usepackage[left=1.2in,right=1.2in,top=1.2in,bottom=1.2in]{geometry}
\usepackage{titling}
\setlength{\droptitle}{2in}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage{rotating}
\usepackage{graphics}
\usepackage{fancyhdr}
\pagestyle{fancy}

\lhead{University of Illinois at Urbana-Champaign}
\rhead{page \thepage}

\lstset{frame=tb,
		language=C++,
		aboveskip=3mm,
		belowskip=3mm,
		showstringspaces=false,
		columns=flexible,
		basicstyle={\small\ttfamily},
		numbers=none,
		%numberstyle=\tiny\color{gray},
		%keywordstyle=\color{dkgreen},
		commentstyle=\color{mauve},
		breaklines=true,
		breakatwhitespace=true,
		tabsize=3
}


\begin{document}
\begin{turn}{270}
    \includegraphics[scale=0.7]{frontpage.pdf}
\end{turn}
\thispagestyle{empty}
\newpage

\begin{multicols}{2}
\setcounter{page}{1}
\pagenumbering{arabic}
\pagestyle{fancy}
\tableofcontents
\newpage

\section{Data Structures}
\subsection{Segment Tree 2D}
\begin{lstlisting}
void build_y(int k_x, int k_y, int l, int r) {
    if (l == r) { 
        t[k_x][k_y] = 0; 
        return;
    }
    int mid = (l + r) >> 1;
    build_y(k_x, k_y * 2, l, mid);
    build_y(k_x, k_y * 2 + 1, mid + 1, r);
    t[k_x][k_y] = 0;
}

void build_x(int k, int l, int r) {
    build_y(k, 1, 1, n);
    if (l == r) return;
    int mid = (l + r) >> 1;
    build_x(k * 2, l, mid);
    build_x(k * 2 + 1, mid + 1, r);
}

void update_y(int k_x, int l_x, int r_x, int k_y, int l_y, int r_y, int y, int v) {
    if (y < l_y || r_y < y) return;
    if (l_y == r_y) {
        if (l_x == r_x)
            t[k_x][k_y] += v;
        else
            t[k_x][k_y] = t[k_x * 2][k_y] + t[k_x * 2 + 1][k_y];
        return;
    }
    int mid = (l_y + r_y) >> 1;
    update_y(k_x, l_x, r_x, k_y * 2, l_y, mid, y, v);
    update_y(k_x, l_x, r_x, k_y * 2 + 1, mid + 1, r_y, y, v);
    t[k_x][k_y] = t[k_x][k_y * 2] + t[k_x][k_y * 2 + 1];
}

void update_x(int k, int l, int r, int x, int y, int v) {
    if (x < l || r < x) return;
    if (l == r) {
        update_y(k, l, r, 1, 1, n, y, v);
        return;
    }
    int mid = (l + r) >> 1;
    update_x(k * 2, l, mid, x, y, v);
    update_x(k * 2 + 1, mid + 1, r, x, y, v);
    update_y(k, l, r, 1, 1, n, y, v);
}

int get_y(int k_x, int k_y, int l, int r, int y1, int y2) {
    if (y2 < l || r < y1) return 0;
    if (y1 <= l && r <= y2) return t[k_x][k_y];
    int mid = (l + r) >> 1;
    return get_y(k_x, k_y * 2, l, mid, y1, y2) +
           get_y(k_x, k_y * 2 + 1, mid + 1, r, y1, y2); 
}

int get_x(int k, int l, int r, int x1, int x2, int y1, int y2) {
    if (r < x1 || x2 < l) return 0;
    if (x1 <= l && r <= x2)
        return get_y(k, 1, 1, n, y1, y2);
    int mid = (l + r) >> 1;
    return get_x(k * 2, l, mid, x1, x2, y1, y2) +
           get_x(k * 2 + 1, mid + 1, r, x1, x2, y1, y2); 
}
\end{lstlisting}
\subsection{Splay Tree}
\begin{lstlisting}
// Supports reversing a segment.
struct SplayTree {
    struct Node {
        Node *left, *right, *parent;
        int value, size;
        bool reversed;
    };

    SplayTree() {
        nilt = new Node();
        nilt->left = nilt->right = nilt->parent = nilt;
        nilt->value = nilt->size = 0;
        nilt->reversed = false;
    }

    void set_left(Node* x, Node* y) {
        x->left = y;
        y->parent = x;
    }

    void set_right(Node* x, Node* y) {
        x->right = y;
        y->parent = x;
    }

    void set_child(Node* x, Node* y, bool is_right) {
        if (is_right) set_right(x, y);
        else set_left(x, y);
    }

    void build_tree(vector < int >& arr) {
        root = nilt;
        for (int i = 0; i < arr.size(); ++i) {
            Node* x = new Node();
            x->size = arr[i];
            x->value = arr[i];
            x->reversed = false;
            set_left(x, root);
            x->parent = x->right = nilt;
            root = x;
        }
    }

    void propagate(Node* x) {
        if (x == nilt) return;
        if (x->reversed) {
            swap(x->left, x->right);
            x->left->reversed = !x->left->reversed;
            x->right->reversed = !x->right->reversed;
            x->reversed = false;
        }
    }

    Node* locate(Node* x, int pos) {
        do {
            propagate(x);
            int num = x->left->size + 1;
            if (num == pos) return x;
            if (num > pos) x = x->left;
            else
                pos -= num, x = x->right;
        } while (true);
        return x;
    }

    void update(Node* x) {
        x->size = x->left->size + x->right->size + 1;
    }

    void uptree(Node* x) {
        Node* y = x->parent;
        Node* z = y->parent;
        if (x == y->right) {
            Node* b = x->left;
            set_right(y, b);
            set_left(x, y);
        }
        else {
            Node* b = x->right;
            set_left(y, b);
            set_right(x, y);
        }
        update(y);
        update(x);
        set_child(z, x, z->right == y);
    }

    void splay(Node* x) {
        do {
            Node* y = x->parent;
            if (y == nilt) return;
            Node* z = y->parent;
            if (z != nilt) {
                if ((x == y->left) == (y == z->left))
                    uptree(y);
                else
                    uptree(x);
            }
            uptree(x);
        } while (true);
    }

    void split(Node* t, int pos, Node*& t1, Node*& t2) {
        if (pos == 0) {
            t1 = nilt;
            t2 = t;
            return;
        }
        if (pos >= t->size) {
            t1 = t;
            t2 = nilt;
            return;
        }
        Node* x = locate(t, pos);
        splay(x);
        t1 = x;
        t2 = x->right;
        t1->right = nilt;
        t2->parent = nilt;
        update(t1);
    }

    Node* join(Node* t1, Node* t2) {
        if (t1 == nilt) return t2;
        t1 = locate(t1, t1->size);
        splay(t1); 
        set_right(t1, t2);
        update(t1);
        return t1;
    }

    Node *root, *nilt;
};
\end{lstlisting}
\section{Graph Theory}
\subsection{Centroid Decomposition}
\begin{lstlisting}
void build(int u, int p) {
    sze[u] = 1;
    for (int v : adj[u])
        if (!elim[v] && v != p) build(v, u), sze[u] += sze[v];
}

int get_centroid(int u, int p, int num) {
    for (int v : adj[u])
        if (!elim[v] && v != p && sze[v] > num / 2)
            return get_centroid(v, u, num);
    return u;
}

void centroid_decomposition(int u) {
    build(u, -1);
    int root = get_centroid(u, -1, sze[u]);
    // Do stuffs here
    elim[root] = true;
    for (int v : adj[root])
        if (!elim[v]) centroid_decomposition(v, c + 1);
}
\end{lstlisting}
\subsection{Heavy Light Decomposition}
\begin{lstlisting}
void build(int u) {
    size_tree[u] = 1;
    for (int i = 0; i < adj[u].size(); ++i) {
        int v = adj[u][i];
        if (parent[u] == v) continue;
        parent[v] = u;
        build(v);
        size_tree[u] += size_tree[v];
    }
}

void hld(int u) {
    if (chain_head[num_chain] == 0)
        chain_head[num_chain] = u;
    chain_idx[u] = num_chain;
    arr_idx[u] = ++num_arr;
    node_arr[num_arr] = u;
    
    int heavy_child = -1;
    for (int i = 0; i < adj[u].size(); ++i) {
        int v = adj[u][i];
        if (parent[u] == v) continue;
        if (heavy_child == -1 || size_tree[v] > size_tree[heavy_child])
            heavy_child = v;
    }

    if (heavy_child != -1)
        hld(heavy_child);

    for (int i = 0; i < adj[u].size(); ++i) {
        int v = adj[u][i];
        if (v == heavy_child || parent[u] == v) continue;
        ++num_chain;
        hld(v);
    }
}

// u is an ancestor of v
int query_hld(int u, int v) {
    int uchain = chain_idx[u], vchain = chain_idx[v], ans = -1;
    while (true) {
        if (uchain == vchain) {
            get(..., arr_idx[u], arr_idx[v]);
            break;
        }
        get(..., arr_idx[chain_head[vchain]], arr_idx[v]);
        v = parent[chain_head[vchain]];
        vchain = chain_idx[v];
    }
    return ans;
}
\end{lstlisting}

\end{multicols}
\end{document}

